{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { createPermissionHook, Platform, UnavailabilityError } from 'expo-modules-core';\nimport * as React from 'react';\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport ExponentCamera from \"./ExponentCamera\";\nimport CameraManager from \"./ExponentCameraManager\";\nimport { ConversionTables, ensureNativeProps } from \"./utils/props\";\nvar EventThrottleMs = 500;\nvar _PICTURE_SAVED_CALLBACKS = {};\nvar _GLOBAL_PICTURE_ID = 1;\nfunction ensurePictureOptions(options) {\n  var pictureOptions = !options || typeof options !== 'object' ? {} : options;\n  if (!pictureOptions.quality) {\n    pictureOptions.quality = 1;\n  }\n  if (pictureOptions.onPictureSaved) {\n    var id = _GLOBAL_PICTURE_ID++;\n    _PICTURE_SAVED_CALLBACKS[id] = pictureOptions.onPictureSaved;\n    pictureOptions.id = id;\n    pictureOptions.fastMode = true;\n  }\n  return pictureOptions;\n}\nfunction ensureRecordingOptions(options) {\n  var recordingOptions = options || {};\n  if (!recordingOptions || typeof recordingOptions !== 'object') {\n    recordingOptions = {};\n  } else if (typeof recordingOptions.quality === 'string') {\n    recordingOptions.quality = Camera.Constants.VideoQuality[recordingOptions.quality];\n  }\n  return recordingOptions;\n}\nfunction _onPictureSaved(_ref) {\n  var nativeEvent = _ref.nativeEvent;\n  var id = nativeEvent.id,\n    data = nativeEvent.data;\n  var callback = _PICTURE_SAVED_CALLBACKS[id];\n  if (callback) {\n    callback(data);\n    delete _PICTURE_SAVED_CALLBACKS[id];\n  }\n}\nvar Camera = function (_React$Component) {\n  _inherits(Camera, _React$Component);\n  var _super = _createSuper(Camera);\n  function Camera() {\n    var _this;\n    _classCallCheck(this, Camera);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this._lastEvents = {};\n    _this._lastEventsTimes = {};\n    _this._onCameraReady = function () {\n      if (_this.props.onCameraReady) {\n        _this.props.onCameraReady();\n      }\n    };\n    _this._onMountError = function (_ref2) {\n      var nativeEvent = _ref2.nativeEvent;\n      if (_this.props.onMountError) {\n        _this.props.onMountError(nativeEvent);\n      }\n    };\n    _this._onObjectDetected = function (callback) {\n      return function (_ref3) {\n        var nativeEvent = _ref3.nativeEvent;\n        var type = nativeEvent.type;\n        if (_this._lastEvents[type] && _this._lastEventsTimes[type] && JSON.stringify(nativeEvent) === _this._lastEvents[type] && new Date().getTime() - _this._lastEventsTimes[type].getTime() < EventThrottleMs) {\n          return;\n        }\n        if (callback) {\n          callback(nativeEvent);\n          _this._lastEventsTimes[type] = new Date();\n          _this._lastEvents[type] = JSON.stringify(nativeEvent);\n        }\n      };\n    };\n    _this._setReference = function (ref) {\n      if (ref) {\n        _this._cameraRef = ref;\n        if (Platform.OS === 'web') {\n          _this._cameraHandle = ref;\n        } else {\n          _this._cameraHandle = findNodeHandle(ref);\n        }\n      } else {\n        _this._cameraRef = null;\n        _this._cameraHandle = null;\n      }\n    };\n    return _this;\n  }\n  _createClass(Camera, [{\n    key: \"takePictureAsync\",\n    value: function () {\n      var _takePictureAsync = _asyncToGenerator(function* (options) {\n        var pictureOptions = ensurePictureOptions(options);\n        return yield CameraManager.takePicture(pictureOptions, this._cameraHandle);\n      });\n      function takePictureAsync(_x) {\n        return _takePictureAsync.apply(this, arguments);\n      }\n      return takePictureAsync;\n    }()\n  }, {\n    key: \"getSupportedRatiosAsync\",\n    value: function () {\n      var _getSupportedRatiosAsync = _asyncToGenerator(function* () {\n        if (!CameraManager.getSupportedRatios) {\n          throw new UnavailabilityError('Camera', 'getSupportedRatiosAsync');\n        }\n        return yield CameraManager.getSupportedRatios(this._cameraHandle);\n      });\n      function getSupportedRatiosAsync() {\n        return _getSupportedRatiosAsync.apply(this, arguments);\n      }\n      return getSupportedRatiosAsync;\n    }()\n  }, {\n    key: \"getAvailablePictureSizesAsync\",\n    value: function () {\n      var _getAvailablePictureSizesAsync = _asyncToGenerator(function* (ratio) {\n        if (!CameraManager.getAvailablePictureSizes) {\n          throw new UnavailabilityError('Camera', 'getAvailablePictureSizesAsync');\n        }\n        return yield CameraManager.getAvailablePictureSizes(ratio, this._cameraHandle);\n      });\n      function getAvailablePictureSizesAsync(_x2) {\n        return _getAvailablePictureSizesAsync.apply(this, arguments);\n      }\n      return getAvailablePictureSizesAsync;\n    }()\n  }, {\n    key: \"recordAsync\",\n    value: function () {\n      var _recordAsync = _asyncToGenerator(function* (options) {\n        if (!CameraManager.record) {\n          throw new UnavailabilityError('Camera', 'recordAsync');\n        }\n        var recordingOptions = ensureRecordingOptions(options);\n        return yield CameraManager.record(recordingOptions, this._cameraHandle);\n      });\n      function recordAsync(_x3) {\n        return _recordAsync.apply(this, arguments);\n      }\n      return recordAsync;\n    }()\n  }, {\n    key: \"stopRecording\",\n    value: function stopRecording() {\n      if (!CameraManager.stopRecording) {\n        throw new UnavailabilityError('Camera', 'stopRecording');\n      }\n      CameraManager.stopRecording(this._cameraHandle);\n    }\n  }, {\n    key: \"pausePreview\",\n    value: function pausePreview() {\n      if (!CameraManager.pausePreview) {\n        throw new UnavailabilityError('Camera', 'pausePreview');\n      }\n      CameraManager.pausePreview(this._cameraHandle);\n    }\n  }, {\n    key: \"resumePreview\",\n    value: function resumePreview() {\n      if (!CameraManager.resumePreview) {\n        throw new UnavailabilityError('Camera', 'resumePreview');\n      }\n      CameraManager.resumePreview(this._cameraHandle);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var nativeProps = ensureNativeProps(this.props);\n      var onBarCodeScanned = this.props.onBarCodeScanned ? this._onObjectDetected(this.props.onBarCodeScanned) : undefined;\n      var onFacesDetected = this._onObjectDetected(this.props.onFacesDetected);\n      return React.createElement(ExponentCamera, _objectSpread(_objectSpread({}, nativeProps), {}, {\n        ref: this._setReference,\n        onCameraReady: this._onCameraReady,\n        onMountError: this._onMountError,\n        onBarCodeScanned: onBarCodeScanned,\n        onFacesDetected: onFacesDetected,\n        onPictureSaved: _onPictureSaved\n      }));\n    }\n  }], [{\n    key: \"isAvailableAsync\",\n    value: function () {\n      var _isAvailableAsync = _asyncToGenerator(function* () {\n        if (!CameraManager.isAvailableAsync) {\n          throw new UnavailabilityError('expo-camera', 'isAvailableAsync');\n        }\n        return yield CameraManager.isAvailableAsync();\n      });\n      function isAvailableAsync() {\n        return _isAvailableAsync.apply(this, arguments);\n      }\n      return isAvailableAsync;\n    }()\n  }, {\n    key: \"getAvailableCameraTypesAsync\",\n    value: function () {\n      var _getAvailableCameraTypesAsync = _asyncToGenerator(function* () {\n        if (!CameraManager.getAvailableCameraTypesAsync) {\n          throw new UnavailabilityError('expo-camera', 'getAvailableCameraTypesAsync');\n        }\n        return yield CameraManager.getAvailableCameraTypesAsync();\n      });\n      function getAvailableCameraTypesAsync() {\n        return _getAvailableCameraTypesAsync.apply(this, arguments);\n      }\n      return getAvailableCameraTypesAsync;\n    }()\n  }, {\n    key: \"getAvailableVideoCodecsAsync\",\n    value: function () {\n      var _getAvailableVideoCodecsAsync = _asyncToGenerator(function* () {\n        if (!CameraManager.getAvailableVideoCodecsAsync) {\n          throw new UnavailabilityError('Camera', 'getAvailableVideoCodecsAsync');\n        }\n        return yield CameraManager.getAvailableVideoCodecsAsync();\n      });\n      function getAvailableVideoCodecsAsync() {\n        return _getAvailableVideoCodecsAsync.apply(this, arguments);\n      }\n      return getAvailableVideoCodecsAsync;\n    }()\n  }, {\n    key: \"getPermissionsAsync\",\n    value: function () {\n      var _getPermissionsAsync = _asyncToGenerator(function* () {\n        console.warn(\"\\\"getPermissionsAsync()\\\" is now deprecated. Please use \\\"getCameraPermissionsAsync()\\\" or \\\"getMicrophonePermissionsAsync()\\\" instead.\");\n        return CameraManager.getPermissionsAsync();\n      });\n      function getPermissionsAsync() {\n        return _getPermissionsAsync.apply(this, arguments);\n      }\n      return getPermissionsAsync;\n    }()\n  }, {\n    key: \"requestPermissionsAsync\",\n    value: function () {\n      var _requestPermissionsAsync = _asyncToGenerator(function* () {\n        console.warn(\"\\\"requestPermissionsAsync()\\\" is now deprecated. Please use \\\"requestCameraPermissionsAsync()\\\" or \\\"requestMicrophonePermissionsAsync()\\\" instead.\");\n        return CameraManager.requestPermissionsAsync();\n      });\n      function requestPermissionsAsync() {\n        return _requestPermissionsAsync.apply(this, arguments);\n      }\n      return requestPermissionsAsync;\n    }()\n  }, {\n    key: \"getCameraPermissionsAsync\",\n    value: function () {\n      var _getCameraPermissionsAsync = _asyncToGenerator(function* () {\n        return CameraManager.getCameraPermissionsAsync();\n      });\n      function getCameraPermissionsAsync() {\n        return _getCameraPermissionsAsync.apply(this, arguments);\n      }\n      return getCameraPermissionsAsync;\n    }()\n  }, {\n    key: \"requestCameraPermissionsAsync\",\n    value: function () {\n      var _requestCameraPermissionsAsync = _asyncToGenerator(function* () {\n        return CameraManager.requestCameraPermissionsAsync();\n      });\n      function requestCameraPermissionsAsync() {\n        return _requestCameraPermissionsAsync.apply(this, arguments);\n      }\n      return requestCameraPermissionsAsync;\n    }()\n  }, {\n    key: \"getMicrophonePermissionsAsync\",\n    value: function () {\n      var _getMicrophonePermissionsAsync = _asyncToGenerator(function* () {\n        return CameraManager.getMicrophonePermissionsAsync();\n      });\n      function getMicrophonePermissionsAsync() {\n        return _getMicrophonePermissionsAsync.apply(this, arguments);\n      }\n      return getMicrophonePermissionsAsync;\n    }()\n  }, {\n    key: \"requestMicrophonePermissionsAsync\",\n    value: function () {\n      var _requestMicrophonePermissionsAsync = _asyncToGenerator(function* () {\n        return CameraManager.requestMicrophonePermissionsAsync();\n      });\n      function requestMicrophonePermissionsAsync() {\n        return _requestMicrophonePermissionsAsync.apply(this, arguments);\n      }\n      return requestMicrophonePermissionsAsync;\n    }()\n  }]);\n  return Camera;\n}(React.Component);\nCamera.Constants = {\n  Type: CameraManager.Type,\n  FlashMode: CameraManager.FlashMode,\n  AutoFocus: CameraManager.AutoFocus,\n  WhiteBalance: CameraManager.WhiteBalance,\n  VideoQuality: CameraManager.VideoQuality,\n  VideoStabilization: CameraManager.VideoStabilization || {},\n  VideoCodec: CameraManager.VideoCodec\n};\nCamera.ConversionTables = ConversionTables;\nCamera.defaultProps = {\n  zoom: 0,\n  ratio: '4:3',\n  focusDepth: 0,\n  faceDetectorSettings: {},\n  type: CameraManager.Type.back,\n  autoFocus: CameraManager.AutoFocus.on,\n  flashMode: CameraManager.FlashMode.off,\n  whiteBalance: CameraManager.WhiteBalance.auto\n};\nCamera.useCameraPermissions = createPermissionHook({\n  getMethod: Camera.getCameraPermissionsAsync,\n  requestMethod: Camera.requestCameraPermissionsAsync\n});\nCamera.useMicrophonePermissions = createPermissionHook({\n  getMethod: Camera.getMicrophonePermissionsAsync,\n  requestMethod: Camera.requestMicrophonePermissionsAsync\n});\nexport { Camera as default };\nvar Constants = Camera.Constants,\n  getPermissionsAsync = Camera.getPermissionsAsync,\n  requestPermissionsAsync = Camera.requestPermissionsAsync,\n  getCameraPermissionsAsync = Camera.getCameraPermissionsAsync,\n  requestCameraPermissionsAsync = Camera.requestCameraPermissionsAsync,\n  getMicrophonePermissionsAsync = Camera.getMicrophonePermissionsAsync,\n  requestMicrophonePermissionsAsync = Camera.requestMicrophonePermissionsAsync;\nexport { Constants, getPermissionsAsync, requestPermissionsAsync, getCameraPermissionsAsync, requestCameraPermissionsAsync, getMicrophonePermissionsAsync, requestMicrophonePermissionsAsync };","map":{"version":3,"sources":["../src/Camera.tsx"],"names":[],"mappings":"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","sourcesContent":["import { createPermissionHook, Platform, UnavailabilityError } from 'expo-modules-core';\nimport * as React from 'react';\nimport { findNodeHandle } from 'react-native';\n\nimport {\n  CameraCapturedPicture,\n  CameraPictureOptions,\n  CameraProps,\n  CameraRecordingOptions,\n  CameraType,\n  ConstantsType,\n  PermissionResponse,\n  VideoCodec,\n} from './Camera.types';\nimport ExponentCamera from './ExponentCamera';\nimport CameraManager from './ExponentCameraManager';\nimport { ConversionTables, ensureNativeProps } from './utils/props';\n\nconst EventThrottleMs = 500;\n\nconst _PICTURE_SAVED_CALLBACKS = {};\n\nlet _GLOBAL_PICTURE_ID = 1;\n\nfunction ensurePictureOptions(options?: CameraPictureOptions): CameraPictureOptions {\n  const pictureOptions: CameraPictureOptions =\n    !options || typeof options !== 'object' ? {} : options;\n\n  if (!pictureOptions.quality) {\n    pictureOptions.quality = 1;\n  }\n  if (pictureOptions.onPictureSaved) {\n    const id = _GLOBAL_PICTURE_ID++;\n    _PICTURE_SAVED_CALLBACKS[id] = pictureOptions.onPictureSaved;\n    pictureOptions.id = id;\n    pictureOptions.fastMode = true;\n  }\n  return pictureOptions;\n}\n\nfunction ensureRecordingOptions(options?: CameraRecordingOptions): CameraRecordingOptions {\n  let recordingOptions = options || {};\n\n  if (!recordingOptions || typeof recordingOptions !== 'object') {\n    recordingOptions = {};\n  } else if (typeof recordingOptions.quality === 'string') {\n    recordingOptions.quality = Camera.Constants.VideoQuality[recordingOptions.quality];\n  }\n\n  return recordingOptions;\n}\n\nfunction _onPictureSaved({\n  nativeEvent,\n}: {\n  nativeEvent: { data: CameraCapturedPicture; id: number };\n}) {\n  const { id, data } = nativeEvent;\n  const callback = _PICTURE_SAVED_CALLBACKS[id];\n  if (callback) {\n    callback(data);\n    delete _PICTURE_SAVED_CALLBACKS[id];\n  }\n}\n\nexport default class Camera extends React.Component<CameraProps> {\n  /**\n   * Check whether the current device has a camera. This is useful for web and simulators cases.\n   * This isn't influenced by the Permissions API (all platforms), or HTTP usage (in the browser).\n   * You will still need to check if the native permission has been accepted.\n   * @platform web\n   */\n  static async isAvailableAsync(): Promise<boolean> {\n    if (!CameraManager.isAvailableAsync) {\n      throw new UnavailabilityError('expo-camera', 'isAvailableAsync');\n    }\n\n    return await CameraManager.isAvailableAsync();\n  }\n\n  /**\n   * Returns a list of camera types `['front', 'back']`. This is useful for desktop browsers which only have front-facing cameras.\n   * @platform web\n   */\n  static async getAvailableCameraTypesAsync(): Promise<CameraType[]> {\n    if (!CameraManager.getAvailableCameraTypesAsync) {\n      throw new UnavailabilityError('expo-camera', 'getAvailableCameraTypesAsync');\n    }\n\n    return await CameraManager.getAvailableCameraTypesAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Queries the device for the available video codecs that can be used in video recording.\n   * @return A promise that resolves to a list of strings that represents available codecs.\n   * @platform ios\n   */\n  static async getAvailableVideoCodecsAsync(): Promise<VideoCodec[]> {\n    if (!CameraManager.getAvailableVideoCodecsAsync) {\n      throw new UnavailabilityError('Camera', 'getAvailableVideoCodecsAsync');\n    }\n\n    return await CameraManager.getAvailableVideoCodecsAsync();\n  }\n\n  static Constants: ConstantsType = {\n    Type: CameraManager.Type,\n    FlashMode: CameraManager.FlashMode,\n    AutoFocus: CameraManager.AutoFocus,\n    WhiteBalance: CameraManager.WhiteBalance,\n    VideoQuality: CameraManager.VideoQuality,\n    VideoStabilization: CameraManager.VideoStabilization || {},\n    VideoCodec: CameraManager.VideoCodec,\n  };\n\n  // Values under keys from this object will be transformed to native options\n  static ConversionTables = ConversionTables;\n\n  static defaultProps: CameraProps = {\n    zoom: 0,\n    ratio: '4:3',\n    focusDepth: 0,\n    faceDetectorSettings: {},\n    type: CameraManager.Type.back,\n    autoFocus: CameraManager.AutoFocus.on,\n    flashMode: CameraManager.FlashMode.off,\n    whiteBalance: CameraManager.WhiteBalance.auto,\n  };\n\n  // @needsAudit\n  /**\n   * @deprecated Use `getCameraPermissionsAsync` or `getMicrophonePermissionsAsync` instead.\n   * Checks user's permissions for accessing camera.\n   */\n  static async getPermissionsAsync(): Promise<PermissionResponse> {\n    console.warn(\n      `\"getPermissionsAsync()\" is now deprecated. Please use \"getCameraPermissionsAsync()\" or \"getMicrophonePermissionsAsync()\" instead.`\n    );\n    return CameraManager.getPermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Asks the user to grant permissions for accessing camera.\n   * On iOS this will require apps to specify both `NSCameraUsageDescription` and `NSMicrophoneUsageDescription` entries in the **Info.plist**.\n   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).\n   * @deprecated Use `requestCameraPermissionsAsync` or `requestMicrophonePermissionsAsync` instead.\n   */\n  static async requestPermissionsAsync(): Promise<PermissionResponse> {\n    console.warn(\n      `\"requestPermissionsAsync()\" is now deprecated. Please use \"requestCameraPermissionsAsync()\" or \"requestMicrophonePermissionsAsync()\" instead.`\n    );\n    return CameraManager.requestPermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Checks user's permissions for accessing camera.\n   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).\n   */\n  static async getCameraPermissionsAsync(): Promise<PermissionResponse> {\n    return CameraManager.getCameraPermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Asks the user to grant permissions for accessing camera.\n   * On iOS this will require apps to specify an `NSCameraUsageDescription` entry in the **Info.plist**.\n   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).\n   */\n  static async requestCameraPermissionsAsync(): Promise<PermissionResponse> {\n    return CameraManager.requestCameraPermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Check or request permissions to access the camera.\n   * This uses both `requestCameraPermissionsAsync` and `getCameraPermissionsAsync` to interact with the permissions.\n   *\n   * @example\n   * ```ts\n   * const [status, requestPermission] = Camera.useCameraPermissions();\n   * ```\n   */\n  static useCameraPermissions = createPermissionHook({\n    getMethod: Camera.getCameraPermissionsAsync,\n    requestMethod: Camera.requestCameraPermissionsAsync,\n  });\n\n  // @needsAudit\n  /**\n   * Checks user's permissions for accessing microphone.\n   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).\n   */\n  static async getMicrophonePermissionsAsync(): Promise<PermissionResponse> {\n    return CameraManager.getMicrophonePermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Asks the user to grant permissions for accessing the microphone.\n   * On iOS this will require apps to specify an `NSMicrophoneUsageDescription` entry in the **Info.plist**.\n   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).\n   */\n  static async requestMicrophonePermissionsAsync(): Promise<PermissionResponse> {\n    return CameraManager.requestMicrophonePermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Check or request permissions to access the microphone.\n   * This uses both `requestMicrophonePermissionsAsync` and `getMicrophonePermissionsAsync` to interact with the permissions.\n   *\n   * @example\n   * ```ts\n   * const [status, requestPermission] = Camera.useMicrophonePermissions();\n   * ```\n   */\n  static useMicrophonePermissions = createPermissionHook({\n    getMethod: Camera.getMicrophonePermissionsAsync,\n    requestMethod: Camera.requestMicrophonePermissionsAsync,\n  });\n\n  _cameraHandle?: number | null;\n  _cameraRef?: React.Component | null;\n  _lastEvents: { [eventName: string]: string } = {};\n  _lastEventsTimes: { [eventName: string]: Date } = {};\n\n  // @needsAudit\n  /**\n   * Takes a picture and saves it to app's cache directory. Photos are rotated to match device's orientation\n   * (if `options.skipProcessing` flag is not enabled) and scaled to match the preview. Anyway on Android it is essential\n   * to set ratio prop to get a picture with correct dimensions.\n   * > **Note**: Make sure to wait for the [`onCameraReady`](#oncameraready) callback before calling this method.\n   * @param options An object in form of `CameraPictureOptions` type.\n   * @return Returns a Promise that resolves to `CameraCapturedPicture` object, where `uri` is a URI to the local image file on iOS,\n   * Android, and a base64 string on web (usable as the source for an `Image` element). The `width` and `height` properties specify\n   * the dimensions of the image. `base64` is included if the `base64` option was truthy, and is a string containing the JPEG data\n   * of the image in Base64--prepend that with `'data:image/jpg;base64,'` to get a data URI, which you can use as the source\n   * for an `Image` element for example. `exif` is included if the `exif` option was truthy, and is an object containing EXIF\n   * data for the image--the names of its properties are EXIF tags and their values are the values for those tags.\n   *\n   * > On native platforms, the local image URI is temporary. Use [`FileSystem.copyAsync`](filesystem.md#filesystemcopyasyncoptions)\n   * > to make a permanent copy of the image.\n   *\n   * > On web, the `uri` is a base64 representation of the image because file system URLs are not supported in the browser.\n   * > The `exif` data returned on web is a partial representation of the [`MediaTrackSettings`](https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings),\n   * > if available.\n   */\n  async takePictureAsync(options?: CameraPictureOptions): Promise<CameraCapturedPicture> {\n    const pictureOptions = ensurePictureOptions(options);\n\n    return await CameraManager.takePicture(pictureOptions, this._cameraHandle);\n  }\n\n  /**\n   * Get aspect ratios that are supported by the device and can be passed via `ratio` prop.\n   * @return Returns a Promise that resolves to an array of strings representing ratios, eg. `['4:3', '1:1']`.\n   * @platform android\n   */\n  async getSupportedRatiosAsync(): Promise<string[]> {\n    if (!CameraManager.getSupportedRatios) {\n      throw new UnavailabilityError('Camera', 'getSupportedRatiosAsync');\n    }\n\n    return await CameraManager.getSupportedRatios(this._cameraHandle);\n  }\n\n  /**\n   * Get picture sizes that are supported by the device for given `ratio`.\n   * @param ratio A string representing aspect ratio of sizes to be returned.\n   * @return Returns a Promise that resolves to an array of strings representing picture sizes that can be passed to `pictureSize` prop.\n   * The list varies across Android devices but is the same for every iOS.\n   */\n  async getAvailablePictureSizesAsync(ratio?: string): Promise<string[]> {\n    if (!CameraManager.getAvailablePictureSizes) {\n      throw new UnavailabilityError('Camera', 'getAvailablePictureSizesAsync');\n    }\n    return await CameraManager.getAvailablePictureSizes(ratio, this._cameraHandle);\n  }\n\n  /**\n   * Starts recording a video that will be saved to cache directory. Videos are rotated to match device's orientation.\n   * Flipping camera during a recording results in stopping it.\n   * @param options A map of `CameraRecordingOptions` type.\n   * @return Returns a Promise that resolves to an object containing video file `uri` property and a `codec` property on iOS.\n   * The Promise is returned if `stopRecording` was invoked, one of `maxDuration` and `maxFileSize` is reached or camera preview is stopped.\n   * @platform android\n   * @platform ios\n   */\n  async recordAsync(options?: CameraRecordingOptions): Promise<{ uri: string }> {\n    if (!CameraManager.record) {\n      throw new UnavailabilityError('Camera', 'recordAsync');\n    }\n\n    const recordingOptions = ensureRecordingOptions(options);\n    return await CameraManager.record(recordingOptions, this._cameraHandle);\n  }\n\n  /**\n   * Stops recording if any is in progress.\n   */\n  stopRecording() {\n    if (!CameraManager.stopRecording) {\n      throw new UnavailabilityError('Camera', 'stopRecording');\n    }\n\n    CameraManager.stopRecording(this._cameraHandle);\n  }\n\n  /**\n   * Pauses the camera preview. It is not recommended to use `takePictureAsync` when preview is paused.\n   */\n  pausePreview() {\n    if (!CameraManager.pausePreview) {\n      throw new UnavailabilityError('Camera', 'pausePreview');\n    }\n\n    CameraManager.pausePreview(this._cameraHandle);\n  }\n\n  /**\n   * Resumes the camera preview.\n   */\n  resumePreview() {\n    if (!CameraManager.resumePreview) {\n      throw new UnavailabilityError('Camera', 'resumePreview');\n    }\n\n    CameraManager.resumePreview(this._cameraHandle);\n  }\n\n  _onCameraReady = () => {\n    if (this.props.onCameraReady) {\n      this.props.onCameraReady();\n    }\n  };\n\n  _onMountError = ({ nativeEvent }: { nativeEvent: { message: string } }) => {\n    if (this.props.onMountError) {\n      this.props.onMountError(nativeEvent);\n    }\n  };\n\n  _onObjectDetected =\n    (callback?: Function) =>\n    ({ nativeEvent }: { nativeEvent: any }) => {\n      const { type } = nativeEvent;\n      if (\n        this._lastEvents[type] &&\n        this._lastEventsTimes[type] &&\n        JSON.stringify(nativeEvent) === this._lastEvents[type] &&\n        new Date().getTime() - this._lastEventsTimes[type].getTime() < EventThrottleMs\n      ) {\n        return;\n      }\n\n      if (callback) {\n        callback(nativeEvent);\n        this._lastEventsTimes[type] = new Date();\n        this._lastEvents[type] = JSON.stringify(nativeEvent);\n      }\n    };\n\n  _setReference = (ref?: React.Component) => {\n    if (ref) {\n      this._cameraRef = ref;\n      // TODO(Bacon): Unify these - perhaps with hooks?\n      if (Platform.OS === 'web') {\n        this._cameraHandle = ref as any;\n      } else {\n        this._cameraHandle = findNodeHandle(ref);\n      }\n    } else {\n      this._cameraRef = null;\n      this._cameraHandle = null;\n    }\n  };\n\n  render() {\n    const nativeProps = ensureNativeProps(this.props);\n\n    const onBarCodeScanned = this.props.onBarCodeScanned\n      ? this._onObjectDetected(this.props.onBarCodeScanned)\n      : undefined;\n\n    const onFacesDetected = this._onObjectDetected(this.props.onFacesDetected);\n\n    return (\n      <ExponentCamera\n        {...nativeProps}\n        ref={this._setReference}\n        onCameraReady={this._onCameraReady}\n        onMountError={this._onMountError}\n        onBarCodeScanned={onBarCodeScanned}\n        onFacesDetected={onFacesDetected}\n        onPictureSaved={_onPictureSaved}\n      />\n    );\n  }\n}\n\nexport const {\n  Constants,\n  getPermissionsAsync,\n  requestPermissionsAsync,\n  getCameraPermissionsAsync,\n  requestCameraPermissionsAsync,\n  getMicrophonePermissionsAsync,\n  requestMicrophonePermissionsAsync,\n} = Camera;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}